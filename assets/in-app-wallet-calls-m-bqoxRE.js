import{aa as m,L as p,v as w,ab as f}from"./index-fWVVae5R.js";import{d as T,f as h,s as b,g}from"./index-B7QugfGr.js";async function H(e){const{account:t,transactions:c}=e;if(!t)throw new Error("not connected");if(c.length===0)throw new Error("No transactions to send");const n=c[0];if(!n)throw new Error("No transactions to send");if(t.sendBatchTransaction){const a=await Promise.all(c.map(async s=>{const[r,l,o,d]=await Promise.all([T(s),h(s.to),h(s.accessList),h(s.value)]);return{accessList:o,chainId:s.chain.id,data:r,to:l,value:d}}));return{...await t.sendBatchTransaction(a),chain:n.chain,client:n.client}}throw new Error("Account doesn't implement sendBatchTransaction")}async function y(e){const t=await b(e);return m(t)}const u=new p(1e3);async function C(e){const{account:t,calls:c}=e,n=c.map(s=>({...s,chain:e.chain})),a=[],i=g(65);if(u.set(i,a),t.sendBatchTransaction){const s=await H({account:t,transactions:n});a.push(s.transactionHash),u.set(i,a)}else for(const s of n){const r=await y({account:t,transaction:s});a.push(r.transactionHash),u.set(i,a)}return i}async function E(e){const{chain:t,client:c,id:n}=e,a=u.get(n);if(!a)throw new Error("Failed to get calls status, unknown bundle id");const i=w({chain:t,client:c});let s="success";const r=await Promise.all(a.map(l=>f(i,{hash:l}).then(o=>({blockHash:o.blockHash,blockNumber:o.blockNumber,gasUsed:o.gasUsed,logs:o.logs.map(d=>({address:d.address,data:d.data,topics:d.topics})),status:o.status,transactionHash:o.transactionHash})).catch(()=>(s="pending",null))));return{atomic:!1,chainId:t.id,id:n,receipts:r.filter(l=>l!==null),status:s,statusCode:200,version:"2.0.0"}}export{E as inAppWalletGetCallsStatus,C as inAppWalletSendCalls};
